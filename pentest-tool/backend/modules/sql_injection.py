from typing import Dict, Any
from .base_scanner import BaseScanner
import requests
from urllib.parse import urljoin
import re
import time


class SQLInjectionScanner(BaseScanner):
    """
    Scanner for detecting basic SQL injection vulnerabilities.
    """
    
    def __init__(self):
        super().__init__()
        self.name = "SQL Injection Scanner"
        self.description = "Quick scan for SQL injection vulnerabilities"
        self.payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT NULL--",
            "admin' --",
            "' OR '1'='1' #",
            "') OR ('1'='1",
            "1' ORDER BY 1--",
        ]
        self.error_patterns = [
            "sql syntax",
            "mysql_fetch",
            "sql command",
            "unclosed quotation",
            "sql statement",
            "ORA-",
            "PostgreSQL",
            "SQLite"
        ]
    
    def check_response_for_sql_errors(self, response_text: str) -> bool:
        """Check if the response contains SQL error messages."""
        response_lower = response_text.lower()
        return any(pattern.lower() in response_lower for pattern in self.error_patterns)
    
    def scan_url(self, url: str) -> Dict[str, Any]:
        """Scan a single URL for SQL injection vulnerabilities."""
        try:
            # Test normal request first
            normal_response = requests.get(url, timeout=5)
            normal_content = normal_response.text
            
            vulnerabilities = []
            
            # Test each payload
            for payload in self.payloads:
                try:
                    # Add payload to URL parameters
                    test_url = url + ("&" if "?" in url else "?") + "id=" + payload
                    
                    # Send request with payload
                    response = requests.get(test_url, timeout=5)
                    
                    # Check for SQL errors in response
                    if self.check_response_for_sql_errors(response.text):
                        vulnerabilities.append({
                            "payload": payload,
                            "type": "SQL Error Detected",
                            "url": test_url
                        })
                        continue
                    
                    # Check for significant response differences
                    if len(response.text) > len(normal_content) * 1.5:
                        vulnerabilities.append({
                            "payload": payload,
                            "type": "Unusual Response Length",
                            "url": test_url
                        })
                    
                except requests.RequestException:
                    continue
            
            return {
                "url_tested": url,
                "vulnerabilities": vulnerabilities,
                "total_vulnerabilities": len(vulnerabilities)
            }
            
        except requests.RequestException as e:
            return {"error": f"Failed to test URL: {str(e)}"}
    
    def scan(self, url: str) -> Dict[str, Any]:
        """
        Scan the website for SQL injection vulnerabilities.
        """
        if not self.validate_url(url):
            return {"error": "Invalid URL provided"}
        
        try:
            # Start with the main URL
            results = self.scan_url(url)
            
            # Get all forms if the URL is accessible
            try:
                response = requests.get(url, timeout=5)
                forms = re.findall(r'<form.*?action=["\']([^"\']*)["\']', response.text)
                
                # Test form submission URLs
                for form_url in forms[:3]:  # Limit to first 3 forms
                    full_url = urljoin(url, form_url)
                    form_results = self.scan_url(full_url)
                    if "vulnerabilities" in form_results:
                        results["vulnerabilities"].extend(form_results["vulnerabilities"])
            except requests.RequestException:
                pass
            
            return {
                "scanner": self.name,
                "url": url,
                "vulnerabilities_found": len(results.get("vulnerabilities", [])) > 0,
                "details": results
            }
            
        except Exception as e:
            return {
                "error": f"Error during scan: {str(e)}",
                "scanner": self.name,
                "url": url
            } 