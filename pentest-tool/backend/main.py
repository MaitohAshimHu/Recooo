from fastapi import FastAPI, HTTPException, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, HttpUrl
from typing import Dict, Any, List

from modules.sql_injection import SQLInjectionScanner
from modules.xss import XSSScanner
from modules.csrf import CSRFScanner

import asyncio
import json
from datetime import datetime

# Request model
class ScanRequest(BaseModel):
    url: HttpUrl

app = FastAPI(
    title="Pentest Tool API",
    description="Backend API for the penetration testing tool",
    version="0.1.0",
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Update this in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Store active WebSocket connections
active_connections: List[WebSocket] = []

# Queue for log messages
log_messages = asyncio.Queue()

# Log a message and send it to all WebSocket clients
async def log_message(message: str, level: str = "info", scan_type: str = None, url: str = None):
    log_entry = {
        "timestamp": datetime.now().isoformat(),
        "level": level,
        "message": message,
        "scan_type": scan_type,
        "url": url
    }
    
    # Add to queue for any late-joining clients
    await log_messages.put(log_entry)
    
    # Send to all active connections
    if active_connections:
        for connection in active_connections:
            try:
                await connection.send_text(json.dumps(log_entry))
            except Exception as e:
                print(f"Error sending to WebSocket: {e}")

# Background task to maintain log messages
@app.on_event("startup")
async def startup_event():
    # Start the log processor
    asyncio.create_task(process_logs())

async def process_logs():
    while True:
        # This keeps the queue processing even when there are no consumers
        log_entry = await log_messages.get()
        log_messages.task_done()
        # Could store logs in memory or database here if needed

@app.websocket("/ws/logs")
async def websocket_logs(websocket: WebSocket):
    await websocket.accept()
    active_connections.append(websocket)
    
    try:
        # Send initial message
        await websocket.send_text(json.dumps({
            "timestamp": datetime.now().isoformat(),
            "level": "info",
            "message": "Connected to log stream",
            "scan_type": None,
            "url": None
        }))
        
        # Keep the connection alive
        while True:
            # Wait for any message from the client (can be used for ping/pong)
            data = await websocket.receive_text()
            if data == "ping":
                await websocket.send_text(json.dumps({
                    "timestamp": datetime.now().isoformat(),
                    "level": "info",
                    "message": "pong",
                    "scan_type": None,
                    "url": None
                }))
    except WebSocketDisconnect:
        active_connections.remove(websocket)
    except Exception as e:
        print(f"WebSocket error: {e}")
        if websocket in active_connections:
            active_connections.remove(websocket)

@app.get("/")
async def root():
    return {"message": "Welcome to the Pentest Tool API"}

@app.get("/health")
async def health_check():
    return {"status": "ok"}

@app.get("/ping")
async def ping():
    return {"message": "pong"}

@app.post("/scan/sql")
async def scan_sql_injection(scan_request: ScanRequest) -> Dict[str, Any]:
    """
    Scan a URL for SQL injection vulnerabilities
    """
    url = str(scan_request.url)
    await log_message(f"Starting SQL injection scan for {url}", "info", "sql", url)
    
    scanner = SQLInjectionScanner()
    
    try:
        await log_message(f"Running SQL injection tests on {url}", "info", "sql", url)
        result = scanner.scan(url)
        
        if "error" in result:
            await log_message(f"Error in SQL injection scan: {result['error']}", "error", "sql", url)
        else:
            await log_message(f"SQL injection scan completed for {url}", "success", "sql", url)
        
        return result
    except Exception as e:
        error_msg = str(e)
        await log_message(f"Exception during SQL injection scan: {error_msg}", "error", "sql", url)
        raise HTTPException(status_code=500, detail=error_msg)

@app.post("/scan/xss")
async def scan_xss(scan_request: ScanRequest) -> Dict[str, Any]:
    """
    Scan a URL for XSS vulnerabilities
    """
    url = str(scan_request.url)
    await log_message(f"Starting XSS scan for {url}", "info", "xss", url)
    
    scanner = XSSScanner()
    
    try:
        await log_message(f"Running XSS tests on {url}", "info", "xss", url)
        result = scanner.scan(url)
        
        if "error" in result:
            await log_message(f"Error in XSS scan: {result['error']}", "error", "xss", url)
        else:
            await log_message(f"XSS scan completed for {url}", "success", "xss", url)
        
        return result
    except Exception as e:
        error_msg = str(e)
        await log_message(f"Exception during XSS scan: {error_msg}", "error", "xss", url)
        raise HTTPException(status_code=500, detail=error_msg)

@app.post("/scan/csrf")
async def scan_csrf(scan_request: ScanRequest) -> Dict[str, Any]:
    """
    Scan a URL for CSRF vulnerabilities
    """
    url = str(scan_request.url)
    await log_message(f"Starting CSRF scan for {url}", "info", "csrf", url)
    
    scanner = CSRFScanner()
    
    try:
        await log_message(f"Running CSRF tests on {url}", "info", "csrf", url)
        result = scanner.scan(url)
        
        if "error" in result:
            await log_message(f"Error in CSRF scan: {result['error']}", "error", "csrf", url)
        else:
            await log_message(f"CSRF scan completed for {url}", "success", "csrf", url)
        
        return result
    except Exception as e:
        error_msg = str(e)
        await log_message(f"Exception during CSRF scan: {error_msg}", "error", "csrf", url)
        raise HTTPException(status_code=500, detail=error_msg)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)